<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!-- IMPORTS for custom elements etc -->
<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../shared-styles.html">

<link rel="import" href="../../bower_components/paper-input/paper-textarea.html">

<link ref="import" href="../../bower_components/polymerfire/polymerfire.html">

<link rel="import" href="../../bower_components/polymerfire/firebase-document.html">

<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-toast/paper-toast.html">


<!-- Start Element -->
<dom-module id="comment-element">
  <template>
    <style include="shared-styles">
      :host {
        /*hide when not opened*/
        display: none;
        /*position: absolute;
        overflow: hidden;
        top: 46px;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1;*/
      }
      :host([opened]){
        display: block;
      }
      /* Custom css for tag - TO replace with <tag> custom element! */
      
      .tag {
        padding: 3px 5px;
        margin: 4px 5px;
        border: 1px grey solid;
        border-radius: 4px;
        background-color: #e8ede8;
        display: inline-block;
      }
      
      .selectedTag {
        background-color: rgb(52, 152, 48);
        border: 1px green solid;
      }
      
      .card.half {
        width: 30%;
        display: inline-block;
      }
      
      .submit {
        background-color: rgb(33, 110, 14);
        color: white;
        clear: both;
      }
      
      .Blue {
        background-color: blue!important;
        color: white;
      }
      
      .Green {
        background-color: green!important;
        color: white;
      }
      
      .Red {
        background-color: red!important;
        color: white;
      }
      
      #commentCard {
        
      }
      /*paper-toast {
        bottom: 0;
        left: 0;
        width: 100%;
      }*/
    </style>
    <!-- Main comment input -->
    <div class="card" id="commentCard">
      <h1>[[question.text]]</h1>
      <div id="commentEdit" hidden$="[[commentSaved]]">
        <h5>1. Add a personal comment into the pot:</h5>
        <paper-textarea label="Add a comment" always-float-label value="{{comment.text}}"></paper-textarea>
        <!-- Submit Comment Button -->
        <h5>2. Tag your post</h5>
        <br/><br/>
        <paper-button raised on-tap="addComment" class$="[[group]]">
          Submit Your Comment
        </paper-button>
        <paper-toast id="submittedText" text="Comment submitted"></paper-toast>
      </div>
      <div class="savedComment" hidden$="[[!commentSaved]]">
        <p class='comment'>[[comment.text]]</p>
        <span>Tags: </span>
        <template id='tagRepeat' is='dom-repeat' items='[[comment.tags]]' as='tag'>
          <div class='tag'>[[tag]]</div>
        </template>
        <br><br>
        <paper-button raised on-tap="editComment" class$="[[group]]">
          Edit
        </paper-button>
      </div>
      <!-- end card -->
    </div>

    <firebase-document 
    id="commentDoc" 
    path="[[commentPath]]" 
    app-name="firebaseApp1"
    data="{{comment}}"
    >
    </firebase-document>



  </template>

  <!-- Scripts for element -->
  <script>
    Polymer({
      is: 'comment-element',

      properties: {
        comment: {
          type: Object,
          value:{}
        },
        commentSaved: {
          type: Boolean,
          value: false
        },
        savedComments:{
          type:Object,
          value:{}
        },
        opened:{
          type:Boolean,
          // keep html attribute and property value in sync to cause observable change
          reflectToAttribute:true,
          readOnly:true,
          value:true
        },
        // define question object here so can be used from template markup
        question:{
          type:Object,
          // notify allows to-way binding to element from parent or other elements
          notify:true
        }
      },

      observers: [
      ],

      open:function(){
        if (!this.pushId) { this.pushId = generatePushID() }
        console.log('question opened',this.question)
        this.commentPath="questions/"+this.question.$key+"/comments/"+this.pushId
        //if load any existing comments and unhide editor if none
        if(this.savedComments[this.question.$key]){
          this.comment=this.savedComments[this.question.$key]
          console.log('existing comment',this.comment)
        }
        else{
          this.comment={}
          this.commentSaved=false
        }
      },

      newGroup: function () {
        this.set('comment.group', this.group);
      },

      addComment: function () {
        if (this.comment.text && this.question.$key && this.comment.text != "") {
          this.comment.timestamp = Date.now()
          //generate unique id to be used for comment and editing
          if (!this.pushId) { this.pushId = generatePushID() }
          console.log('path',this.commentPath)
          console.log('push id', this.pushId)
          console.log('comment',this.comment)
          this.$.commentDoc.save(this.commentPath, this.pushId).then(function () {
            this.savedComments[this.question.$key]=this.comment
            this.commentSaved = true;
            //this.comment = {};
          }.bind(this))
        }
      },

      editComment: function () {
        this.commentSaved = false;
      },
      checkForEnter: function (e) {
        if (e.keyCode === 13) {
          this.addTag();

        }
      },

    });

    //code used by polymer to create pushid. As not exposed to api (?) running manually
    // https://gist.github.com/mikelehen/3596a30bd69384624c11
    generatePushID = (function () {
      // Modeled after base64 web-safe chars, but ordered by ASCII.
      var PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';
      // Timestamp of last push, used to prevent local collisions if you push twice in one ms.
      var lastPushTime = 0;
      // We generate 72-bits of randomness which get turned into 12 characters and appended to the
      // timestamp to prevent collisions with other clients.  We store the last characters we
      // generated because in the event of a collision, we'll use those same characters except
      // "incremented" by one.
      var lastRandChars = [];
      return function () {
        var now = new Date().getTime();
        var duplicateTime = (now === lastPushTime);
        lastPushTime = now;
        var timeStampChars = new Array(8);
        for (var i = 7; i >= 0; i--) {
          timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
          // NOTE: Can't use << here because javascript will convert to int and lose the upper bits.
          now = Math.floor(now / 64);
        }
        if (now !== 0) throw new Error('We should have converted the entire timestamp.');
        var id = timeStampChars.join('');
        if (!duplicateTime) {
          for (i = 0; i < 12; i++) {
            lastRandChars[i] = Math.floor(Math.random() * 64);
          }
        } else {
          // If the timestamp hasn't changed since last push, use the same random number, except incremented by 1.
          for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
            lastRandChars[i] = 0;
          }
          lastRandChars[i]++;
        }
        for (i = 0; i < 12; i++) {
          id += PUSH_CHARS.charAt(lastRandChars[i]);
        }
        if (id.length != 20) throw new Error('Length should be 20.');
        return id;
      };
    })();
  </script>

</dom-module>